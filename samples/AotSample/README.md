# MagicOnion AOT Sample

This sample demonstrates how to use MagicOnion with Native AOT compilation.

## Project Structure

```
AotSample/
├── AotSample.Server/     # AOT-compatible server application
│   ├── Services/         # Service implementations
│   ├── MagicOnionMessagePackFormatters.cs  # Custom formatters for DynamicArgumentTuple
│   └── Program.cs        # Server configuration
└── AotSample.Shared/     # Shared interfaces and DTOs
    ├── IGreeterService.cs
    ├── IChatHub.cs
    ├── UserProfile.cs    # MessagePackObject DTOs
    └── AotSampleResolver.cs  # Generated MessagePack resolver
```

## Key Components for AOT Support

### 1. Source Generators

MagicOnion AOT requires two source generators:

- **MagicOnion.Server.SourceGenerator**: Generates static method providers for services
- **Multicaster.SourceGenerator**: Generates static proxy factories for StreamingHub broadcast

```xml
<!-- AotSample.Server.csproj -->
<ProjectReference Include="MagicOnion.Server.SourceGenerator" OutputItemType="Analyzer" />
<ProjectReference Include="Multicaster.SourceGenerator" OutputItemType="Analyzer" />
```

### 2. MessagePack Configuration

#### Custom Resolver for DynamicArgumentTuple

Methods with 2+ parameters use `DynamicArgumentTuple<T1, T2, ...>` internally. You must register formatters manually:

```csharp
// MagicOnionMessagePackFormatters.cs
public class MagicOnionAotFormatterResolver : IFormatterResolver
{
    public static readonly MagicOnionAotFormatterResolver Instance = new();
    
    public IMessagePackFormatter<T>? GetFormatter<T>()
    {
        return FormatterCache<T>.Formatter;
    }
    
    private static class FormatterCache<T>
    {
        public static readonly IMessagePackFormatter<T>? Formatter;
        static FormatterCache()
        {
            Formatter = (IMessagePackFormatter<T>?)MagicOnionAotFormatters.GetFormatter(typeof(T));
        }
    }
}

public static class MagicOnionAotFormatters
{
    // Register formatters for each DynamicArgumentTuple type used
    private static readonly DynamicArgumentTupleFormatter<int, int> _intIntFormatter = new(default, default);
    
    public static object? GetFormatter(Type type)
    {
        if (type == typeof(DynamicArgumentTuple<int, int>)) return _intIntFormatter;
        return null;
    }
}
```

#### MessagePackObject DTOs

For custom DTOs, use MessagePack's source generator:

```csharp
// AotSampleResolver.cs
[GeneratedMessagePackResolver]
public partial class AotSampleResolver;

// UserProfile.cs
[MessagePackObject]
public class UserProfile
{
    [Key(0)] public int Id { get; set; }
    [Key(1)] public string Name { get; set; } = string.Empty;
}
```

#### Resolver Configuration

Configure MessagePack with AOT-compatible resolvers:

```csharp
var messagePackOptions = MessagePackSerializerOptions.Standard
    .WithResolver(CompositeResolver.Create(
        MagicOnionAotFormatterResolver.Instance,  // DynamicArgumentTuple formatters
        AotSampleResolver.Instance,                // Generated DTO formatters
        BuiltinResolver.Instance,                  // Primitives, arrays, etc.
        AttributeFormatterResolver.Instance,       // [MessagePackFormatter] types
        PrimitiveObjectResolver.Instance           // object type support
    ));
```

> **Important**: Do NOT use `StandardResolver.Instance` as it includes `GeneratedMessagePackResolver` which uses reflection to instantiate formatters and fails in AOT.

### 3. Server Configuration

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddGrpc();
builder.Services.AddMagicOnion(options =>
{
    options.MessageSerializer = MessagePackMagicOnionSerializerProvider.Default
        .WithOptions(messagePackOptions);
})
    .UseStaticMethodProvider<MagicOnionMethodProvider>()    // Generated by source generator
    .UseStaticProxyFactory<MulticasterProxyFactory>();      // Generated by source generator

var app = builder.Build();
app.MapMagicOnionService();
app.Run();
```

### 4. Project Configuration

```xml
<!-- AotSample.Server.csproj -->
<PropertyGroup>
    <PublishAot>true</PublishAot>
    <InvariantGlobalization>true</InvariantGlobalization>
    <!-- Suppress AOT warnings from libraries using dynamic code -->
    <SuppressTrimAnalysisWarnings>true</SuppressTrimAnalysisWarnings>
    <NoWarn>$(NoWarn);IL3050;IL3053</NoWarn>
</PropertyGroup>
```

## Building and Publishing

### Debug Build
```bash
dotnet build
```

### AOT Publish
```bash
dotnet publish -c Release -r win-x64
# or for Linux
dotnet publish -c Release -r linux-x64
```

The published executable will be in `bin/Release/net10.0/<rid>/publish/`.

## Adding New Services

### Unary Service

1. Define interface in Shared project:
```csharp
public interface IMyService : IService<IMyService>
{
    UnaryResult<string> HelloAsync(string name);
    UnaryResult<int> AddAsync(int a, int b);  // 2+ params need DynamicArgumentTuple formatter
}
```

2. Implement in Server project:
```csharp
public class MyService : ServiceBase<IMyService>, IMyService
{
    public UnaryResult<string> HelloAsync(string name) 
        => UnaryResult.FromResult($"Hello, {name}!");
    
    public UnaryResult<int> AddAsync(int a, int b) 
        => UnaryResult.FromResult(a + b);
}
```

3. Register `DynamicArgumentTupleFormatter` for methods with 2+ parameters:
```csharp
// In MagicOnionAotFormatters.GetFormatter()
if (type == typeof(DynamicArgumentTuple<int, int>)) 
    return new DynamicArgumentTupleFormatter<int, int>(default, default);
```

### StreamingHub

1. Define interfaces in Shared project:
```csharp
public interface IChatHubReceiver
{
    void OnMessage(string user, string message);  // 2+ params need formatter
}

public interface IChatHub : IStreamingHub<IChatHub, IChatHubReceiver>
{
    Task JoinAsync(string room, string user);  // 2+ params need formatter
    Task SendMessageAsync(string message);
}
```

2. Implement in Server project:
```csharp
public class ChatHub : StreamingHubBase<IChatHub, IChatHubReceiver>, IChatHub
{
    // Implementation
}
```

3. Register formatters for receiver methods with 2+ parameters:
```csharp
if (type == typeof(DynamicArgumentTuple<string, string>)) 
    return new DynamicArgumentTupleFormatter<string, string>(default!, default!);
```

## Checklist for AOT Compatibility

- [ ] Add `MagicOnion.Server.SourceGenerator` as analyzer
- [ ] Add `Multicaster.SourceGenerator` as analyzer (for StreamingHub)
- [ ] Create `[GeneratedMessagePackResolver]` partial class for DTOs
- [ ] Register `DynamicArgumentTupleFormatter` for all methods with 2+ parameters
- [ ] Use `UseStaticMethodProvider<T>()` and `UseStaticProxyFactory<T>()`
- [ ] Configure `CompositeResolver` without `StandardResolver`
- [ ] Set `<PublishAot>true</PublishAot>` in csproj

## Troubleshooting

### "DynamicArgumentTuple is not registered in resolver"
Add the corresponding `DynamicArgumentTupleFormatter<T1, T2, ...>` to `MagicOnionAotFormatters`.

### "Type is not registered in resolver" for custom DTOs
1. Ensure the type has `[MessagePackObject]` attribute
2. Ensure `[GeneratedMessagePackResolver]` partial class exists
3. Add the generated resolver to `CompositeResolver`

### AOT publish warnings
Most warnings are from libraries that don't declare AOT compatibility but work correctly with static providers. Use `<SuppressTrimAnalysisWarnings>true</SuppressTrimAnalysisWarnings>` to suppress them.
